# what
1. 小而自治的services。多个service构成了同一个application。
2. 服务越小，微服务的优势和劣势相对就更加的明显，服务越小，独立性带来的好处就越多，相对来说带来的管理成本就会有所增加。也会越负责。
3. 除了微服务，还有很多其他的把程序拆小的办法。
* Jar，DLL
异构性支持不好，弹性
* module support by framework。like Orchard which include the module life cycle。
同上，边界性不强，人员变动，很快模块就剪不断理还乱了。
4. 采用通用的通信方式，尽量少用集中式的服务管理，如中间件。


# why
1. 天然边界
2. 更加能拥抱变化，相对而言，大家更能接受改变一个几百行代码的服务，而不是几十万行代码。
3. 服务作为组件

# how

## Balance

1. 多小算小，足够小，不要太小
* 两周之内可以完全重写，上下文。
* 换个角度，你的程序大吗？大家都知道大。
* 和组织结构相符合，如果代码库大到团队没有办法维护，那么可能就需要拆掉。

所以是团队觉得合适的粒度
2. 隔离性
* API 应尽可能选择与具体技术无关的标准，比如restful。
3. 是否能修改一个服务，并进行部署，并不影响其他服务。如果不满足这个要求，微服务几乎带来不了多少好处。


# 没有银弹